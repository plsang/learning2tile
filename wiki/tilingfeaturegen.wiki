== User Guild ==
[under construction]
This article introduces the guild to generate the spatial BoW feature for a tiling.

== 1) Find an optimal tiling ==
Suppose we generate this report (see for how to generate it) and we find that <> is the promising tiling.

== 2) Set the environment variables (Optional) ==
Suppose we installed R at "C:\Program Files\R\R-2.15.2\bin" on Windows, we add this variable to the "Path". 

See [http://www.divms.uiowa.edu/help/windows/RPackage.html here] for more information.

On Linux suppose the R home directory is "/data/MM2/R/bin", type

{{{
export PATH=${PATH}:/data/MM2/R/bin
}}} 

See [http://www.cyberciti.biz/faq/set-environment-variable-linux/ here] for more information.

== 3) Download the source package ==
 # Unzip the archive in a folder:
    * a txyc file is the mapping file from centroids to each interest  point's SIFT features. Every image has a txyc file. For example "HVC7.txyc" looks like
      {{{
       10 7 431 569 152 874 504 796 587 37 570 381
       16 7 729 940 600 942 13 992 751 795 945 273
       22 7 316 955 353 163 351 596 570 856 385 432
       28 7 768 203 771 527 477 634 968 847 641 963
       34 7 914 587 120 442 520 714 403 483 569 401
      }}}
     Each row corresponds to a interest point and the first two dimension denotes the point's (x,y) coordinates. The following 10 dimensions list the top 10 nearest centroid IDs (centroid ID starting from 0).
    * The files in the code folder are the source code.
    * "labels.labels" is the class label file.
   
== 3) Config the experiment ==
<code language="R">



#individual runnable tiling code for federate search
args <- commandArgs(TRUE)

if(length(args) != 6) {
	print("Usage:")
	print("resf = c(agrs[1], args[2]) #width height")
	print("DIM = args[3] #dim")
	print("images.txyc.location = args[4] #input txyc filename")
	print("FINAL_BOWDIR = args[5] #output bow DIR")
	print("CodeDir = args[6]  #Code DIR")
	quit()
}

source(paste(args[6], "tiling_lib.r", sep = ""))
source(paste(args[6], "bow_lib.r", sep = ""))

resf = c(as.numeric(args[1]), as.numeric(args[2]))	#width height
DIM = as.numeric(args[3])	#dim
images.txyc.location = args[4]	#input txyc filename
FINAL_BOWDIR = args[5] #output bow DIR




TILING_STYLE = "square"
TILING_PARA = c(2,2)
SOFTMEMBERSHIP_PARA = c(1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10)

getVideoID <- function(filename) {
	return(unlist(strsplit(filename, "\\."))[1])
}


#calculating the dim of the final BOW
if(TILING_STYLE == "square") {
	final.bow.dim <- TILING_PARA[1]*TILING_PARA[2]*DIM
} else if(TILING_STYLE == "diamond") {
	region.all <- TilingDiamond(TILING_PARA[1],TILING_PARA[2], c(), 500, 333)
	final.bow.dim<- length(region.all$tiles)*DIM
} else if(TILING_STYLE == "hexagon") {
	#projecting to the universal screen with
	#width = 555
	#height = 300
	region.all <- TilingHexagon(TILING_PARA, c(), 500, 333)
	final.bow.dim<- length(region.all$tiles)*DIM
} else if(TILING_STYLE == "camera") {
	final.bow.dim <- 5*DIM
} else if(TILING_STYLE == "ellipse") {
	final.bow.dim  <- (TILING_PARA+4)*DIM
} else {
	print("Unkown Tiling Style! Please check it again.")
	quit()
}


{
	
	#check whether the file has been processed
	#if(file.exists(paste(FINAL_BOWDIR,basename(images.txyc.location),".spbow",sep="")))	next;
	print(paste("processing ",basename(images.txyc.location), "...", sep=""))
	
	#for the txyc file
	width = as.numeric(resf[1])
	height = as.numeric(resf[2])
	if(is.na(width)||is.na(height))	{
		print(paste("frame info of ",basename(images.txyc.location), " is missing", sep=""))
		next;
	}
	
	final.bow <- vector(mode="numeric",length=final.bow.dim)
	
	txyc_matrix = matrix(0,0,0)
	#check whether the matrix file is empty?
	if(file.info(images.txyc.location)$size <= 0)  {
		write(final.bow, file=paste(FINAL_BOWDIR,getVideoID(basename(images.txyc.location)),".spbow",sep=""), ncol=length(final.bow))
		next		#empty file
	}
	txyc_matrix <- read.matrix(images.txyc.location)
	if(nrow(txyc_matrix) == 0) {
		write(final.bow, file=paste(FINAL_BOWDIR,getVideoID(basename(images.txyc.location)),".spbow",sep=""), ncol=length(final.bow))
		next									#empty matrix
	}
	
	#adjust the cluster center starting from 1
	txyc_matrix[,3:ncol(txyc_matrix)] = txyc_matrix[,3:ncol(txyc_matrix)]+1
	
	if(TILING_STYLE == "square") {
		region.all <- TilingRectangle(TILING_PARA[1],TILING_PARA[2], txyc_matrix, width, height)
	} else if(TILING_STYLE == "diamond") {
		region.all <- TilingDiamond(TILING_PARA[1],TILING_PARA[2], txyc_matrix, width, height)
	} else if(TILING_STYLE == "camera") {
		region.all <- TilingCamera(TILING_PARA, txyc_matrix, width, height)
	} else if(TILING_STYLE == "hexagon") {
		ptxyc_matrix <- Project2AUniformSize(txyc_matrix, owidth=width, oheight=height, pwidth = 500, pheight = 333)
		region.all <- TilingHexagon(TILING_PARA, ptxyc_matrix, 500, 333)
	} else if(TILING_STYLE == "ellipse") {
		region.all <- TilingEllipse(TILING_PARA, txyc_matrix, width, height)
	}

	
	file.bow = GenSpbow(txyc_matrix, region.all, "l1", SOFTMEMBERSHIP_PARA, DIM)
	
	
	#normalize
	file.bow = file.bow/length(region.all$tiles)
	final.bow = file.bow
	
	#write out the final bag of words of this video
	write(final.bow, file=paste(FINAL_BOWDIR, getVideoID(basename(images.txyc.location)), ".spbow",sep=""), ncol=length(final.bow))		
}

</code>

== Discussion ==

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages